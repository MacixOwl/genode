/*
 * 
 * gongty [at] tongji [dot] edu [dot] cn
 * Created on 2025.2.10 at Yushan, Shangrao
 */

#include "./AppLounge.h"

using namespace monkey;

using monkey::net::IP4Addr;
using monkey::net::protocol::Msg;
using monkey::net::protocol::MsgType;
using monkey::net::protocol::Header;

Status AppLounge::processTryAlloc(adl::size_t blockSize, adl::size_t nBlocks) {

    if (nBlocks != 1) {
        client.sendResponse(1, "Not supported. This mnemosyne only partly support protocol v1.");

        // not supported yet, but should be supported refering to protocol v1.
        return Status::PROTOCOL_ERROR; 
    }

    Block b = context.allocMemoryBlock(blockSize, client.appId);
    if (b.size == 0) {
        client.sendResponse(2, "Failed to alloc. Maybe out of ram.");
        return Status::SUCCESS;
    }

    adl::ArrayList<adl::int64_t> ret;
    ret.append(b.id);
    return client.replyTryAlloc(ret);
}


/**
 * Get memory block from context and check whether this block belongs to the client.
 *
 * If block doesn't exists or it is other client's block, send response with error message and return.
 */
#define GET_AND_VERIFY_BLOCK(blockId, blockVariableName) \
    if (!context.memoryBlocks.hasKey(blockId)) { \
        client.sendResponse(1, "Not your block!"); \
        return Status::SUCCESS; \
    } \
    Block blockVariableName = context.memoryBlocks.getData(blockId); \
    if (blockVariableName.owner != client.appId) { \
        client.sendResponse(1, "Not your block!"); \
        return Status::SUCCESS; \
    }


Status AppLounge::processReadBlock(adl::int64_t blockId) {
    GET_AND_VERIFY_BLOCK(blockId, b);
    return client.replyReadBlock(b.data, b.size);
}


Status AppLounge::processWriteBlock(adl::int64_t blockId, const adl::ByteArray& data) {
    GET_AND_VERIFY_BLOCK(blockId, b);

    if (data.size() != b.size) {
        client.sendResponse(1, "Data size not match.");
        return Status::INVALID_PARAMETERS;
    }

    adl::memcpy(b.data, data.data(), b.size);
    return client.sendResponse(0);
}


Status AppLounge::processCheckAvailMem() {
    adl::size_t availMem = context.env.pd().avail_ram().value;
    availMem -= MONKEY_MNEMOSYNE_HEAP_MEMORY_RESERVED;
    return client.replyCheckAvailMem(availMem);
}


Status AppLounge::processFreeBlock(adl::int64_t blockId) {
    GET_AND_VERIFY_BLOCK(blockId, b);
    context.freeMemoryBlock(b);
    return client.sendResponse(0);
}

#undef GET_AND_VERIFY_BLOCK

Status AppLounge::serve() {

    Genode::log("====== Welcome client (APP) to Sunflower Lounge ======");

    Status status = Status::SUCCESS;


    while (true) {
        Msg* msg = nullptr;
        status = client.recvMsg(&msg);
        if (status != Status::SUCCESS) {
            return status;
        }


        switch ((MsgType) msg->header.type) {
            case MsgType::TryAlloc: {
                // Generated by Google Gemini 2.0 Flash. Checked by GTY.

                adl::size_t blockSize, nBlocks;
                if ((status = client.decodeTryAlloc(msg, &blockSize, &nBlocks)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processTryAlloc(blockSize, nBlocks);
                
                break;
            }
            
            case MsgType::FreeBlock: {
                // Generated by Google Gemini 2.0 Flash. Checked by GTY.

                adl::int64_t blockId;
                if ((status = client.decodeFreeBlock(msg, &blockId)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processFreeBlock(blockId);
                break;
            }
            
            case MsgType::ReadBlock: {
                // Generated by Google Gemini 2.0 Flash. Checked by GTY.

                adl::int64_t blockId;
                if ((status = client.decodeReadBlock(msg, &blockId)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processReadBlock(blockId);
                break;
            }

            case MsgType::WriteBlock: {
                // Generated by Google Gemini 2.0 Flash.

                adl::int64_t blockId;
                adl::ByteArray data;
                if ((status = client.decodeWriteBlock(msg, &blockId, data)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processWriteBlock(blockId, data);
                break;
            }

            case MsgType::CheckAvailMem: {
                processCheckAvailMem();
                break;
            }

            default: {
                Genode::warning("> Message Type NOT SUPPORTED");
                status = Status::PROTOCOL_ERROR;
                client.sendResponse(1, "Msg Type not supported.");
                break;
            }
        }


        adl::defaultAllocator.free(msg);
        if (status != Status::SUCCESS) {
            break;
        }
    }


    return status;
}
