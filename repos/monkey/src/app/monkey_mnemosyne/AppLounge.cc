/*
 * 
 * gongty [at] tongji [dot] edu [dot] cn
 * Created on 2025.2.10 at Yushan, Shangrao
 */

#include "./AppLounge.h"

using namespace monkey;

using monkey::net::IP4Addr;
using monkey::net::protocol::Msg;
using monkey::net::protocol::MsgType;
using monkey::net::protocol::Header;

Status AppLounge::processTryAlloc() {

    Block* b = context.globalMemoryManager.allocMemoryBlock(client.appId, this->context.nodeId);
    if (b == nullptr) {
        client.sendResponse(2, "Failed to alloc. Maybe out of ram.");
        return Status::SUCCESS;
    }

    return client.replyTryAlloc(
        b->id, 
        b->version, 
        b->accessKey.readonly, 
        b->accessKey.readwrite
    );
}


Status AppLounge::processReadBlock(adl::int64_t blockId) {
    auto* b = context.globalMemoryManager.getMemoryBlock(client.appId, blockId, GlobalMemoryManager::READ);


    Genode::log("[AppLounge] ", client.appId, " tries to read block ", blockId, ".");

    if (b == nullptr) {
        Genode::warning("[AppLounge] But block not found or not accessible.");
        client.sendResponse(1, "Block not found or not readable.");
        return Status::INVALID_PARAMETERS;
    }
    return client.replyReadBlock(b->version, b->data);
}


Status AppLounge::processWriteBlock(adl::int64_t blockId, const adl::ByteArray& data) {
    auto* b = context.globalMemoryManager.getMemoryBlock(client.appId, blockId, GlobalMemoryManager::WRITE);

    
    Genode::log("[AppLounge] ", client.appId, " tries to write block ", blockId, ".");

    if (b == nullptr) {
        client.sendResponse(1, "Block not found or not writable.");
        return Status::INVALID_PARAMETERS;
    }

    adl::memcpy(b->data, data.data(), b->size);

    adl::int64_t newVersion = ++b->version;
    adl::int64_t newVerNetOrder = adl::ntohq(newVersion);
    return client.sendResponse(0, sizeof(newVerNetOrder), &newVerNetOrder);
}


Status AppLounge::processCheckAvailMem() {
    adl::size_t availMem = context.env.pd().avail_ram().value;
    availMem -= MONKEY_MNEMOSYNE_HEAP_MEMORY_RESERVED;
    return client.replyCheckAvailMem(availMem);
}


Status AppLounge::processFreeBlock(adl::int64_t blockId) {
    context.globalMemoryManager.unrefMemoryBlock(client.appId, blockId);
    return client.sendResponse(0);
}


Status AppLounge::processRefBlock(adl::int64_t accessKey) {
    adl::int64_t bid = context.globalMemoryManager.refMemoryBlock(client.appId, accessKey);

    if (bid == -1) {
        return client.sendResponse(1);
    }

    adl::int64_t bidNetOrder = adl::htonq(bid);
    return client.sendResponse(0, sizeof(bidNetOrder), &bidNetOrder);
}


Status AppLounge::processUnrefBlock(adl::int64_t blockId) {
    context.globalMemoryManager.unrefMemoryBlock(client.appId, blockId);
    return client.sendResponse(0);
}


Status AppLounge::processGetBlockDataVersion(adl::int64_t blockId) {
    auto* b = context.globalMemoryManager.getMemoryBlock(client.appId, blockId, GlobalMemoryManager::READ);
    if (!b)
        return client.sendResponse(1);
    
    adl::int64_t dataVerNetOrder = adl::htonq(b->version);
    return client.sendResponse(0, sizeof(dataVerNetOrder), &dataVerNetOrder);
}


#undef GET_AND_VERIFY_BLOCK

Status AppLounge::serve() {

    Genode::log("====== Welcome client (APP) to Sunflower Lounge ======");

    Status status = Status::SUCCESS;


    while (true) {
        Msg* msg = nullptr;
        status = client.recvMsg(&msg);
        if (status != Status::SUCCESS) {
            return status;
        }


        switch ((MsgType) msg->header.type) {
            case MsgType::TryAlloc: {
                // Generated by Google Gemini 2.0 Flash. Checked by GTY.

                status = processTryAlloc();
                
                break;
            }
            
            case MsgType::FreeBlock: {
                // Generated by Google Gemini 2.0 Flash. Checked by GTY.

                adl::int64_t blockId;
                if ((status = client.decodeFreeBlock(msg, &blockId)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processFreeBlock(blockId);
                break;
            }
            
            case MsgType::ReadBlock: {
                // Generated by Google Gemini 2.0 Flash. Checked by GTY.

                adl::int64_t blockId;
                if ((status = client.decodeReadBlock(msg, &blockId)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processReadBlock(blockId);
                break;
            }

            case MsgType::WriteBlock: {
                // Generated by Google Gemini 2.0 Flash.

                adl::int64_t blockId;
                adl::ByteArray data;
                if ((status = client.decodeWriteBlock(msg, &blockId, data)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processWriteBlock(blockId, data);
                break;
            }

            case MsgType::CheckAvailMem: {
                processCheckAvailMem();
                break;
            }

            case MsgType::RefBlock: {
                adl::int64_t accessKey;
                if ((status = client.decodeRefBlock(msg, &accessKey)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processRefBlock(accessKey);
                if (status != Status::SUCCESS) {
                    Genode::warning("Failed to ref block with access key ", accessKey);
                }
                break;
            }

            case MsgType::UnrefBlock: {
                adl::int64_t blockId;
                if ((status = client.decodeUnrefBlock(msg, &blockId)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processUnrefBlock(blockId);
                break;
            }

            case MsgType::GetBlockDataVersion: {
                adl::int64_t blockId;
                if ((status = client.decodeGetBlockDataVersion(msg, &blockId)) != Status::SUCCESS) {
                    client.sendResponse(1, "Bad request.");
                    break;
                }
                status = processGetBlockDataVersion(blockId);
                break;
            }

            default: {
                Genode::warning("> Message Type NOT SUPPORTED");
                status = Status::PROTOCOL_ERROR;
                client.sendResponse(1, "Msg Type not supported.");
                break;
            }
        }


        client.freeMsg(msg);
        if (status != Status::SUCCESS) {
            Genode::warning("AppLounge::serve() failed with status: ", adl::int32_t(status), ".");
        }
    }


    return status;
}
